title: Pytest 101 - Python 開發者的測試入門
authors: MingLun Allen Wu
date: 2022-03-04 12:00:00
tags: Python, Test
category: Tool
summary: 待補
slug: pytest_101
top_image: https://images.unsplash.com/photo-1581472723648-909f4851d4ae?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1740&q=80
status: draft

## TL;DR

## 誰適合讀這篇？

+ 會寫 Python ，但沒有測試經驗

## 為何需要測試?

其實在開發過程中，為了確保程式/函式運作正常，在開發完成後，通常都會實際執行一次，確定沒有什麼異常。

舉例來說: 

```python
    # utils.py
    def sum_two_str(str1: str, str2: str) -> str:
        """
        將兩個字串合併在一起:
        Args:
            str1 (str): 字串 1
            str2 (str): 字串 2

        Returns:
            str: 字串1 + 字串2
        """
        return str1 + str2
```

當我們寫了上述的函式，通常會怎麼測試呢? 

我會另外執行一個 `test.py`，實際 import 這個函式，確定行為沒有什麼異常。

```python
    # test.py
    from utils import sum_two_str

    str1 = "冷萃"
    str2 = "咖啡"

    print(sum_two_str(str1= str1, str2= str2)) # 結果應該要是"冷萃咖啡"
```

其實這樣的行為，就是一種測試!

這種行為，通常我們稱為 "Manual Testing" (手動測試)，這種做法有什麼問題嗎?

以我的經驗來說，在專案開發初期，使用 Manual Testing 會有極高的開發效率，彷彿是造物主般，隨心所欲地創造自己的小世界。

但隨著專案的規模成長，函式與模組的數量增加，我開始意識到兩個問題:

1. **`test.py` 的數量越來越肥大**
   
    當一個函式開發完成後，就是我使用 `test.py` 的時機，如同上述的例子，我會實際 import 函式，執行確認結果沒問題，然後開始開發下一個函式。

    下一個函式開發結束後，我會把剛剛的測試程式碼**註解**起來，原因是通常等等會再用到一次，如果刪掉要再重打很麻煩。 接著輸入下一段測試程式碼來手動測試新的函式。 如此持續地迭代。

    發現問題了嗎? 在我的流程中，測試程式碼只會持續地被**註解**起來，到後期會造成開發效率不佳，為了要測試先前寫過的某個函式，我要先滑過被註解的數百行程式碼，找到正確的那段，重新執行。

2. **函式只會測試一次，但偶而會有連鎖反應**

    由於每次 `test.py` 在執行時，只會針對一個函式進行測試，只要通過了，我就會繼續開發下一個函式。
    
    但有時候函式間是會互相影響的，A 函式通過了手動測試，但在開發 B 函式時，可能不小心影響到了 A 函式的行為，導致 A 函式發生錯誤。

    但此時我只會在 `test.py` 測試 B 函式的行為。 
    
    直到執行主程式時，發生出錯了!

    > 唉呀! 真奇怪! 我之前執行時明明都好好的呀!

## 為何需要測試框架

在介紹 `pytest` 這個測試框架前，我們先來談談「測試框架」

我認為「測試框架」的目的，是讓你能

> 有效率的管理並執行測試

手動測試雖然快速且方便，但當專案規模達到一定程度後，不容易管理，且也很難做到重複測試。

+ 測試框架能同時進行多項測試，並將結果以結構化報表的形式呈現。
+ 測試框架能按照測試目的分類，按照需求執行不同類型的測試

以 Python 來說，較主流的測試框架是 `unittest` 及 `pytest`

當初選擇從 `pytest` 入手，是看中它簡單的語法 (只需要依靠 `assert` 就能實現測試)，希望能在開發之餘慢慢摸索。



## 基本架構

使用 `Pytest` 測試框架進行測試時，需要按照特定格式擺放檔案。

並沒有唯一正確的格式，身為一個廣泛使用的測試框架，`Pytest` 可依照使用者的需求自行指定

但是為了方便介紹，讓我們先以下面的架構進行說明：

(此架構同步更新在 [Github Repo](https://github.com/MingLunWu/pytest_101))

```
|
|_ Your Repo
    |
    |_ src/                  # 主要程式碼資料夾
        |_ module_a.py       # 範例模組 A
        |_ module_b.py       # 範例模組 B
    |
    |_ tests/                # 測試程式碼資料夾
        |_ test_module_a.py  # 模組 A 的測試程式碼
        |_ test_module_b.py  # 模組 B 的測試程式碼
    |
    |_ pytest.ini            # pytest 相關設定
```

從上述的架構我們可以掌握幾個原則 : 

+ 主要的程式碼會統一放在 `src/` (也有人稱為 `app`, `lib` 或直接用模組的用途命名) 
+ 測試用的程式碼則統一放在 `tests` 資料夾
+ 通常測試用的程式碼會以 `test_xxx.py` 命名 (我自己的習慣是直接對應到 `src/` 中的模組)

## 撰寫第一個測試

舉例來說，如果在 `src/module_a.py` 中撰寫了: 

```python
# src/module_a.py
    def square(num: int) -> int:
        """範例函式，回傳平方值

        Args:
            num (int): 數值

        Returns:
            int: 平方後的數值
        """
        return num**2
```

如果是一般的手動測試，我們可能會另外開一個 `test.py` 

```python
# test.py
from src.module_a import square

print(square(8)) # 得到 64
```

好！ 經過「肉眼」的判斷，這個函式寫對了！

> 該發生的，一定要發生!

使用 `pytest` 的做法，則是另外撰寫一小段程式碼來確認，這樣的測試函式**必須以`test`** 開頭，通常稱為一個 "Test Case" : 

```python
# tests/test_module_a.py
from src.module_a import square

def test_square():
    assert square(8) == 64
```

測試的方法，是透過 Python 的 `assert` 語法，來做基本的條件判斷: 

```python
# assert <條件為真>, "錯誤訊息"
assert square(8) == 64 # 如果 square(8) 不等於 64，則會發生錯誤
```

透過 `assert` 語法來指定 **「函式應該要達成的條件」**，這個條件會隨著函式的目的而有所不同，以上述例子來說，`square()` 的目的是計算平方值，因此我們需要在 test case `test_square()` 中試著驗證「計算平方值」這件事是否有被達成。

### 執行第一個測試

寫好 Test Case 後，接著在 Terminal 執行: 

```bash
pytest -vv
```

`pytest` 會在執行測試時，自動至測試的資料夾(預設是 `tests`)尋找檔名為 `test_` 開頭的檔案，並且執行開頭為 `test_` 的函數。

執行測試後，會得到下列畫面: 

<img style="display:block; margin-left:auto; margin-right:auto; width:100%;" src="https://minglunwu.github.io/images/20220304/pytest_1.png">

這意味著我們撰寫的第一個 Testing Case - `test_square` 成功通過了！

### 計算 Coverage

接著我們嘗試輸入 : 

```bash
pytest -vv --cov src/
```
`--cov src/` 意味著我們要在執行測試時，計算 `src/` 有多少比例的程式碼是「有被測試過」！

執行後則會得到下列結果：

<img style="display:block; margin-left:auto; margin-right:auto; width:100%;" src="https://minglunwu.github.io/images/20220304/pytest_2.png"><br>

從上圖中可以看到除了原先的測試結果以外，在下方還多了一欄 `coverage` 的表格，顯示了 `src/` 資料夾中的每一個檔案有多少行程式碼(`Stmts`)，以及有多少行程式碼是沒有被測試到的 (`Miss`)。

### 將常用參數寫入至 pytest.ini 中

雖然 flag 很好用，但每次執行 `pytest` 時都需要加上 `-vv`、`--cov src/` 其實並不方便。

這時候我們可以在專案的根目錄加上 `pytest.ini` 檔案，這是 `pytest` 的主要設定檔，執行 `pytest` 時，會自動尋找當前位置是否有 `pytest.ini`，若有，則讀取相關設定後執行:

```yml
[pytest]
addopts= -vv --cov src/
```

`addopts`意味著「添加參數」，我們設定 `-vv` 及 `--cov src`後，接下來只需要執行:

```bash
pytest
```

就會等價於 

```bash
pytest -vv --cov src/
```

如果有更多參數，是在每次執行時都需要附加的話，可以考慮統一放置於 `pytest.ini`，會更省事一些！

## 測試「正確的錯誤」

> 該錯誤的地方，也應該要拋出錯誤

接下來讓我們看看 `src/module_a.py` 的下一個函式

```python
```