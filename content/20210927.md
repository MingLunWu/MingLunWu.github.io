title: Ansible 入門筆記
authors: MingLun Allen Wu
date: 2021-08-27 12:00:00
tags: Python, Ansible
category: Tool
summary: 待補
slug: ansible_note
top_image: https://images.unsplash.com/photo-1478502161016-a691575b097b?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=2070&q=80
status: draft

# TL;DR
`Ansible`是適用於Python環境的自動化組態管理工具，組態(Configuration Management)意味著環境的設定及部署。 使用 `Ansible` 可以將「制式化的系統操作」自動化，讓開發者將注意力投注在值得關注的事物上。

撰寫好「部署的流程」(例如安裝套件、複製檔案...)及「遠端主機的連線資訊」後，即可在數台遠端主機上自動部署，提高部署的效率、降低安裝過程中人為失誤的機率。

# Why Ansible ?

`Ansible`的優勢在於: 

1. 使用Python生態系： 

    近期許多機器學習框架皆是建構於Python生態系

2. 使用SSH連線，不需額外安裝工具:
   
   使用 `Ansible` 對遠端主機進行操作時，是透過 `SSH` 進行遠端操作，意味著不需要在遠端主機額外安裝套件，僅需開啟SSH連接阜即可。 在某些難以安裝套件的環境(例如醫院、銀行)相當方便。

# 使用 Ansible 的目的

+ 提升 Production 環境的穩定性及可靠性

   使用檔案管理「部署內容」，達到 [*Infrastructure as Code*](https://www.trendmicro.com/zh_hk/what-is/cloud-security/infrastructure-as-code.html)，管理上也相對單純，可以使用版本控制進行進退版操作。

+ 減少服務中斷時間
   
    若發生服務中斷，需要將節點下線重新部署，使用`Ansible`進行部署能夠按照「預先設計好的流程」重新部署，不會受限於人員的精神狀況及操作穩定度。

+ 確保環境間(開發、測試、正式)設定對齊
   
    如果同時有多台機器，使用 Ansible 統一部署，可確保在部署過程中統一參考組態檔案，不會發生人為失誤(例如手誤輸入錯誤的資訊)，或是不同部署人員部署順序不一致。

---
# 檔案結構

在學習一個工具時，我習慣先確認「專案的結構該長怎麼樣」，以下是一個 `Ansible` 專案的大致樣貌: 

```
ansible_project
| - README.md
| - INVENTORY_FILE_1  # 概念 - Inventory
| - INVENTORY_FILE_2
| main.yml # 概念 - Playbook
|
| - group_vars/
    | - GROUP1.yml
    | - GROUP2.yml
| - roles/
    | - common/
        | - tasks/
            | - main.yml
        | - handlers/
            | - main.yml
```

# Playbook - 設定工作的流程及步驟

在上方架構中，首先看到 `main.yml`，這是 `Ansible` 專案中的一個 **Playbook(劇本)**，顧名思義在這個檔案中記錄了「做事的方式」及「做事的流程」。

`Playbook` 的範例如下:

```
# main.yml
- name: The example playbook # 階層1 - Play
  hosts: localhost # 定義執行此Play的機器
  vars: # 設定變數
    dynamic_word: "Hello World"

  tasks: # 設定 task
  - name: generate the hello_world.txt file   # 定義 task-1
    command: echo {{ dynamic_world }} > /tmp/hello_word.txt

  - name: show file context   # 定義 task-2
    command: cat /tmp/hello_word.txt
    register: result

  - name: print file result   # 定義 task-3
    debug:
      msg: "{{ result.stdout_lines }}"
```

## Playbook的階層

在 `Playbook` 中包含幾個不同的概念: 

1. `Play`: 定義了「角色」(hosts) 該執行什麼樣的「任務」(task)
2. `Task`: 一個具體的工作，可能是一個具體的 bash 指令 (例如: `echo $PATH`)

+ 在一個 `Playbook` 中可能包含了數個不同的 `Play`:

    分別定義「扮演DB-Server角色」的機器該完成哪些任務、「扮演Web-Server」的機器又該完成哪些任務。

+ 在一個 `Play` 中可能定義了數個 `Task`:
  
    「扮演DB-Server角色」的機器可能需要「建立本地資料夾」、「安裝PostgreDB」、「初始化DB」等三項具體的任務。

以上方的 `main.yml` 來說，我們建立了一個 `Play` (*The example playbook*)，執行這個`Play`的角色是`localhost`(`hosts: localhost`)，而這個 `Play` 裡面包含了三項具體的 `Task` : *generate the hello_world.txt file*, *show file context*, *print file result*

# Inventory - 紀錄機器的群組及連線資訊

使用 `Ansible` 可以快速的管理多台機器，`inventory file` 用來放置機器資訊，這個檔案主要有兩個目的: 

1. 紀錄機器的資訊
2. 為機器進行分組

```
# INVENTORY_FILE_1
[test-server] # 群組名稱
localhost ansible_connection=local

[web-server] # 群組名稱
# 連線資訊
# 機器名稱/連線方式/使用者帳號/使用者密碼(不建議)
webserver ansible_connection=ssh ansible_user=myuser ansible_ssh_pass=password
webserver-2 ansible_connection=ssh ansible_user=myuser-2 ansible_ssh_pass=password2
```

在檔案中我們可以看到 `[test-server]` 和 `[web-server]` 兩個群組，群組內可以放不同的機器資訊以及連線資訊。

對於 `Inventory File` 和 `Group`，我個人的理解是: 

+ `Inventory File` 是用來管理不同的環境(例如 SIT、UAT、PROD)
+ `Group`: 同一個環境中，則用Group來區別不同類型的服務(例如: DB、Web-Server)

