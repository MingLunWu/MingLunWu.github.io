<!DOCTYPE html>
<html lang="en_us">
<head>
        <meta charset="utf-8" />
        <title>MingLun's Blog - Python</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="MingLun's Blog Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">MingLun's Blog</a></h1>
                <nav><ul>
                    <li><a href="/category/deep-learning.html">Deep Learning</a></li>
                    <li><a href="/category/framework.html">Framework</a></li>
                    <li><a href="/category/parallelize.html">Parallelize</a></li>
                    <li><a href="/category/system-related.html">System Related</a></li>
                    <li><a href="/category/tool.html">Tool</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/notes/2020/20200520.html">Python 平行化運算 - Multi-Processing</a></h1>
<footer class="post-info">
        <abbr class="published" title="2020-05-20T18:30:00+08:00">
                Published: 三 20 5月 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/minglun-allen-wu.html">MingLun Allen Wu</a>
        </address>
<p>In <a href="/category/parallelize.html">Parallelize</a>.</p>
<p>tags: <a href="/tag/python.html">Python</a> <a href="/tag/parallelize.html">Parallelize</a> </p>
</footer><!-- /.post-info --><ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#presquile">Presquile</a></li>
<li><a href="#concept">Concept</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<p id="abstract"></p>

<h1>Abstract</h1>
<p>使用Python 進行資料前處理時，大量的資料常會造成處理時間過長，這時候總希望能透過平行化處理來解決。 提到平行化處理又總會陷入疑惑: 「該使用Multi-Thread 還是 Multi-Process」?</p>
<p>以我的經驗，<strong>在進行「資料前處理」時</strong>，其實是需要CPU持續計算的，所以並不適合使用「Multi-thread」。今天這則筆記是嘗試以「Multi-Process」的方式來對前處理階段進行加速。</p>
<p>近期需要使用 <code>transformers</code>套件來將長篇幅的文字轉換成 index，並且裁切成長度512的 array。 <code>transformers</code>執行的速度並不慢，但是當處理的資料達到七～八萬篇時，整個過程也需要耗費將近三個小時。 但是在計算的過程中，打開 <code>htop</code>會發現只使用一顆CPU在計算，這時總會希望能夠用全部的CPU資源來進行加速:</p>
<p><img style="display:block; margin-left:auto; margin-right:auto; width:50%;" src="https://minglunwu.github.io/images/20200520/single_process.png"></p>
<p>我希望能夠透過平行化處理達到下面這個狀態：</p>
<p><img style="display:block; margin-left:auto; margin-right:auto; width:50%;" src="https://minglunwu.github.io/images/20200520/multi_process.png"></p>
<p>最後成功地將處理時間從 2.5小時 縮短到 20 分鐘！</p>
<hr>
<p id="presquile"></p>

<h1>Presquile</h1>
<p>使用 Multi-Processing 進行平行運算前，需要確認:</p>
<ul>
<li>由於不同的<strong>Process間無法共享資料</strong>，所以如果平行運算的過程中需要互相取用資料，就不適合透過Multi-Process的方式執行。   舉例來說：我的碩士論文需要尋訪數萬個字的同義字來建立一個Graph，如果使用Multi-Process是沒有辦法操作一個共同的Graph的。</li>
</ul>
<hr>
<p id="concept"></p>

<h1>Concept</h1>
<p>這次透過 python 內建的 <code>multiprocessing</code>來實作，我們將實作的重要觀念分成四個部分:</p>
<ol>
<li>
<p>Function: </p>
<p>把要透過平行化進行加速的任務封裝在 Function中。</p>
<p>舉例來說如果想要計算當前資料集每一個商品id的"price"欄位總和: </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_function</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s2">&quot;price&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>


</li>
<li>
<p>Tasks:</p>
<p>Tasks是一個 List，因為我們要同時使用多個Process進行計算，所以要在此對參數進行分割。 假設共有 500 篇文章，我們可以將資料分割為:</p>
<div class="highlight"><pre><span></span><span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">100</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="mi">200</span><span class="p">:</span><span class="mi">300</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="mi">300</span><span class="p">:</span><span class="mi">400</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="mi">400</span><span class="p">:</span><span class="mi">500</span><span class="p">]]</span>
</pre></div>


</li>
<li>
<p>Pool:</p>
<p>透過 <code>multiprocessing.pool</code>可以自動建立分工機制，我們不需要做額外的處理與設定:</p>
<div class="highlight"><pre><span></span><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>


</li>
<li>
<p>Map: </p>
<p>在設定好 Function, Tasks 及 Pool後，我們就能透過 <code>pool</code>的 <code>map</code>進行平行處理:</p>
<div class="highlight"><pre><span></span><span class="c1"># 第一個放Function, 第二個放分割後的參數</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sum_function</span><span class="p">,</span> <span class="n">tasks</span><span class="p">)</span>
</pre></div>


</li>
</ol>
<p>執行上述程式碼時， <code>pool</code>會自動將 tasks 中的參數依序丟到 N個 Process中執行 sum_function，並且在執行結束後，將結果回傳到result。 </p>
<p>因為 tasks 中共有5個 Element，所以最後Result也會有5個處理完畢的Element. 這時候可以再根據需要將其 Aggregate成最後的結果。</p>
<p>再來一個較為複雜的範例：</p>
<p>我們要將一個Dataframe先移除 Stop word (<code>remove_stopwrods()</code>)，再將其裁切為長度512的段落(<code>truncate_text()</code>)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

<span class="k">def</span> <span class="nf">remove_stopwords</span><span class="p">(</span><span class="n">text</span><span class="p">):</span> <span class="c1"># 移除 Stop word</span>
        <span class="c1"># Do something.</span>
        <span class="k">return</span> <span class="n">cleaned_text</span>

<span class="k">def</span> <span class="nf">truncate_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>  <span class="c1"># 裁切文字，將長篇幅文字裁切成 512個字的list.</span>
        <span class="c1"># Do something.</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">512</span><span class="n">word_list</span><span class="p">,</span> <span class="mi">512</span><span class="n">word_list</span><span class="p">,</span> <span class="mi">512</span><span class="n">word_list</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">dataframe</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c1"># 儲存每一個Process執行的成果。</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">cleaned_text</span> <span class="o">=</span> <span class="n">remove_stopwords</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">])</span> <span class="c1"># Remove stopwords</span>
        <span class="n">truncated_res</span> <span class="o">=</span> <span class="n">truncate_text</span><span class="p">(</span><span class="n">cleaned_text</span><span class="p">)</span> <span class="c1"># Truncate long words to list.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>


<p>使用到的Function有三項，不需要了解Function的功能是做什麼，只需要知道：</p>
<ol>
<li><code>remove_stopwords()</code>以及 <code>truncate_text()</code>是做資料前處理的兩個function。</li>
<li><code>process()</code>則是接受分割後的「dataframe」，使用 <code>remove_stopwords()</code>及 <code>truncate_text()</code>對dataframe中的每一筆資料進行處理。</li>
</ol>
<p>我們可以在平行化的過程中使用多個Function，但是在使用 <code>multiprocessing.pool</code>進行平行化處理時，只能接受一個Function，所以需要把所有流程中使用到的Function都打包在一起。 (就如同上例將 <code>remove_stopwords()</code>及 <code>truncate_text()</code>都打包在 <code>process()</code>中。)</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">[:</span><span class="mi">100</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="mi">200</span><span class="p">:</span><span class="mi">300</span><span class="p">]]</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">pool</span><span class="p">(</span><span class="n">processes</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">tasks</span><span class="p">)</span> <span class="c1"># 平行處理，全部處理完後會將結果存回 result.</span>

    <span class="n">final_result</span> <span class="o">=</span> <span class="n">some_aggregation</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">#最後可能需要再對資料進行整合。</span>
</pre></div>


<hr>
<p id="conclusion"></p>

<h1>Conclusion</h1>
<p>透過Multi-Process的方式能夠大幅度的提升資料前處理的效率，在沒有集群的情況下，利用多顆CPU來增加速度。 </p>
<p>最近也嘗試在研究 <a href="https://dask.org"><strong>Dask</strong></a>這個套件，能夠輕易地切換不同模式： "Multi-thread"、"Multi-process"以及多台機器組成的集群，對於 <code>Numpy</code>及 <code>Sklearn</code>等機器學習套件也有很好的支援，很適合用來進行Python的平行化處理。</p>
<p>希望本篇筆記對點閱的你有幫助！ 有任何問題歡迎隨時跟我交流！</p>                </article>
            </aside><!-- /#featured -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://getpelican.com/">Pelican</a></li>
                            <li><a href="http://python.org/">Python.org</a></li>
                            <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-161863471-1', 'auto');
    ga('send', 'pageview');
    </script>
</body>
</html>