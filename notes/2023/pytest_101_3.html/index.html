<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="MingLun Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://images.unsplash.com/photo-1581472723648-909f4851d4ae?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1740&q=80"><meta property="twitter:image" content="https://images.unsplash.com/photo-1581472723648-909f4851d4ae?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1740&q=80"><meta name=title content="Pytest 101 - 給 Python 開發者的測試入門 (3) - 圖解 Mock & 測試框架語法整理"><meta property="og:title" content="Pytest 101 - 給 Python 開發者的測試入門 (3) - 圖解 Mock & 測試框架語法整理"><meta property="twitter:title" content="Pytest 101 - 給 Python 開發者的測試入門 (3) - 圖解 Mock & 測試框架語法整理"><meta name=description content><meta property="og:description" content><meta property="twitter:description" content><meta property="twitter:card" content="透過圖解的方式進一步說明 `Mock`，並且整理 `unittest` 和 `pytest-mock` 的使用語法。"><meta name=keyword content="吳明倫, MingLun, minglunwu"><link rel="shortcut icon" href=/img/favicon.ico><title>Pytest 101 - 給 Python 開發者的測試入門 (3) - 圖解 Mock & 測試框架語法整理 | MingLun Blog</title><link rel=canonical href=/notes/2023/pytest_101_3.html/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-NC508K3RBY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NC508K3RBY",{anonymize_ip:!1})}</script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>MingLun Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(https://images.unsplash.com/photo-1581472723648-909f4851d4ae?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1740&q=80)}.utterances{max-width:100%}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/python title=Python>Python</a>
<a class=tag href=/tags/test title=Test>Test</a>
<a class=tag href=/tags/pytest-101 title="Pytest 101">Pytest 101</a></div><h1>Pytest 101 - 給 Python 開發者的測試入門 (3) - 圖解 Mock & 測試框架語法整理</h1><h2 class=subheading></h2><span class=meta>Posted by
MingLun Allen Wu
on
Thursday, August 17, 2023</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=前情提要>前情提要</h1><ul><li><a href=https://minglunwu.com/notes/2022/pytest_101.html/>Pytest 101 - 給 Python 開發者的測試入門</a></li><li><a href=https://minglunwu.com/notes/2023/pytest_101_2.html/>Pytest 101 - 給 Python 開發者的測試入門 (2) - Mock 基礎介紹</a></li></ul><h1 id=tldr>TL;DR</h1><p>本篇筆記透過圖解來進一步說明 Mock 在測試中所扮演的角色。</p><p>此外針對 Python 常見的測試框架 <code>unittest</code> 及 <code>pytest</code>，分別整理了常用的 Mock 語法。</p><p>在內容中所使用到的說明程式碼，你可以在 <a href=https://github.com/MingLunWu/pytest_101>Github - pytest_101</a> 取得。</p><h1 id=前言>前言</h1><p>在前一篇筆記 : <a href=https://minglunwu.com/notes/2023/pytest_101_2.html/>Pytest 101 - 給 Python 開發者的測試入門 (2) - Mock 基礎介紹</a> 中，我們討論了 Mock 的基本概念，也針對幾個實際案例分享了 Mock 的使用方法。</p><p>然而，在實際撰寫測試的過程中，我發現自己對於 Mock 的認知還是有點模糊，在網路上搜尋資料時，常會看到不同的 Mock 語法，因此想要透過這篇筆記進一步梳理。</p><hr><h1 id=範例---呼叫-api>範例 - 呼叫 API</h1><p>在今天的範例中，我們會撰寫一個 Function <code>check_response_greater_than_0_5()</code> :</p><blockquote><p>確認 Response 的數值是否大於 0.5</p></blockquote><p>這個 Function 的目的很單純 :</p><ol><li><strong>呼叫外部的 API</strong> : <code>call_external_api()</code></li><li><strong>嘗試讀取 Response 中的特定數值</strong> : <code>"response_value"</code></li><li><strong>依據 <code>response_value</code> 的數值進行判斷</strong> :<ul><li>如果 <code>response_value > 0.5</code>, 回傳 <code>True</code></li><li>如果 <code>response_value &lt;= 0.5</code>, 回傳 <code>False</code></li><li>如果 <code>response_value</code> 不存在, 拋出錯誤</li></ul></li></ol><p><img src=https://minglunwu.com/images/20230813/image.png alt=基本架構圖></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># src/check_response.py</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> src.external <span style=color:#ff79c6>import</span> call_external_api
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>check_response_greater_than_0_5</span>() <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>bool</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    判斷 call_external_api() 的數值是否大於 0.5
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    external_result <span style=color:#ff79c6>=</span> call_external_api() <span style=color:#6272a4># 呼叫其他 API</span>
</span></span><span style=display:flex><span>    response_value <span style=color:#ff79c6>=</span> external_result<span style=color:#ff79c6>.</span>get(<span style=color:#f1fa8c>&#34;response_value&#34;</span>, <span style=color:#ff79c6>None</span>) <span style=color:#6272a4># 從 Response 中取得 response_value 的數值</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> response_value <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>None</span>: 
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>raise</span> KeyError(<span style=color:#f1fa8c>&#34;response_value not exists!&#34;</span>) <span style=color:#6272a4># 如果 response_value 不存在，拋出錯誤</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>elif</span> external_result <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>0.5</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>True</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>False</span>
</span></span></code></pre></div><p>通常在撰寫測試的過程中，常會遇到某些 Function 或是外部元件包含「不確定性」，意思是 :</p><blockquote><p><strong>我們並不確定與外部元件互動時，得到的 Response 是什麼。</strong></p></blockquote><p>為了模擬這個「不確定性」，我們試著在 <code>call_external_api()</code> 中加入一些隨機性 :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># src/external.py</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> typing <span style=color:#ff79c6>import</span> Dict
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> time
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> random
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>call_external_api</span>() <span style=color:#ff79c6>-&gt;</span> Dict:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;模擬呼叫外部的 API
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Dict: 外部 API 回傳的結果
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    time<span style=color:#ff79c6>.</span>sleep(<span style=color:#bd93f9>0.5</span>)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 有 50% 機率回傳沒有任何資料的 Dict</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> random<span style=color:#ff79c6>.</span>random() <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0.5</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> {}
</span></span><span style=display:flex><span>    response_value <span style=color:#ff79c6>=</span> random<span style=color:#ff79c6>.</span>random()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> {<span style=color:#f1fa8c>&#34;response_value&#34;</span>: response_value}
</span></span></code></pre></div><p>上述程式碼會讓 <code>call_external_api()</code> 的結果有下列可能性 :</p><ul><li><strong>有 50% 機率會出現空白 Response</strong> :<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>{}
</span></span></code></pre></div></li><li><strong>有 50% 機率會回傳隨機的數值</strong> :<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>{<span style=color:#f1fa8c>&#34;response_value&#34;</span>: X} <span style=color:#6272a4># X 為一個隨機數值</span>
</span></span></code></pre></div></li></ul><hr><h1 id=開始撰寫測試>開始撰寫測試</h1><p>接下來，讓我們開始嘗試對 <code>check_response_greater_than_0_5()</code> 撰寫測試，那麼我究竟要測試什麼呢 ?</p><p>我們再看一次 Function 的邏輯圖 :</p><p><img src=https://minglunwu.com/images/20230813/image.png alt=基本架構圖></p><p>從上圖中看到的三個情境，都必須是我們要納入測試的，但是問題來了 :</p><blockquote><p><strong>每次呼叫 <code>call_external_api()</code> 的結果都不同，該如何撰寫測試呢?</strong></p></blockquote><hr><h1 id=圖解-mock>圖解 Mock</h1><p>透過 Mock，我們可以在執行測試的當下，將 <strong>「不穩定的物件」替換成「特定的物件」</strong>，來確保程式碼的邏輯可以被測試。</p><p>舉例來說：</p><p>當我們 <code>call_external_api()</code> 時有 50% 的機率會得到 <code>{}</code>，此時我們的 Function 應該要拋出錯誤訊息。</p><p>然而，如果我們真的在測試的過程中呼叫 <code>call_external_api()</code>，執行 100 次測試中，理論上只有 50 次的情境會得到 <code>{}</code>，其他 50 次會是隨機的 <code>{"response_value": X}</code>。</p><p>當測試的配置相同時，<strong>理論上每次執行測試的結果都應該要完全相同！</strong>，如果每次執行測試，都會出現不同結果，這個測試也就失去意義了。</p><p>為了讓每次測試的結果都一致，我們可以先檢驗第一個條件 :</p><blockquote><p><strong>當 Response 為 {} 時，<code>check_response_greater_than_0_5()</code>必須要拋出錯誤</strong></p></blockquote><p>為了檢驗這個情境是否正確運行，我們需要先確保一件事情 :</p><blockquote><p><strong>讓 Response 回傳 {}</strong></p></blockquote><p>為了達成這個目的，我們可以透過 Mock 來產生一個 <code>mock_api()</code>，替換掉原先的 <code>call_external_api()</code>，使其在測試執行的當下，一定會回傳 <code>{}</code>。</p><p><img src=https://minglunwu.com/images/20230813/image-1.png alt="mock 示意圖"></p><p>如此一來，我們在測試的當下不再需要擔心 <code>call_external_api()</code> 的結果是什麼。而是專注在 :</p><blockquote><p><strong>當 <code>call_external_api()</code> 的結果為 {} 時，當下函式的行為是否正常。</strong></p></blockquote><p>接下來，讓我們將 Mock 擴充到其他不同情境 :</p><ol><li>當 Response 的 <code>response_value > 0.5</code> 時，需要回傳 <code>True</code></li><li>當 Response 不存在 <code>response_value</code> 時，拋出錯誤</li><li>當 Response 的 <code>response_value &lt;= 0.5</code> 時，需要回傳 <code>False</code></li></ol><p>在這三個測試情境下，分別針對 <code>call_external_api()</code> 的結果有一些先決條件，同樣的，我們可以用 Mock 來替換 :</p><p><img src=https://minglunwu.com/images/20230813/image-3.png alt="Test Case 示意圖"></p><p>從上圖可以發現，所謂的 Mock，<strong>其實就是在測試過程中，替換函式中的特定物件</strong>，目的是<strong>驗證特定情況下，函式的行為是否正常</strong>。</p><p>而這樣的行為，我們讓測試的過程中不再受限於 <code>call_external_api()</code> 的變化，而是透過 Mock 來作出「環境隔離」，藉著隔離這些具有「變異性」的物件，將測試的焦點著重在我們的邏輯判斷 (例如 : <code>response_value > 0.5</code> 時要 return <code>True</code>)。</p><hr><h1 id=mock-語法整理>Mock 語法整理</h1><p>初接觸 Mock 時，網路上關於 Mock 的範例會根據測試框架而有所不同，有時候會有點混淆。</p><p>了解 Mock 的概念後，接下來我們來整理不同框架間對於 Mock 的語法，今天想要針對兩種不同框架的 Mock 寫法進行分享 :</p><ol><li><code>unittest</code></li><li><code>pytest_mock</code></li></ol><h2 id=unittest>unittest</h2><p>我認為 <code>unittest</code> 套件的寫法是最好理解 (但可能不是最簡潔) 的。</p><p><img src=https://minglunwu.com/images/20230813/image-3.png alt="Test Case 示意圖"></p><p>以上圖為例，假設我們要建立一個 <code>mock_api_1()</code> 來取代 <code>call_external_api()</code>，我們該怎麼做呢 ?</p><p>使用 <code>unittest</code> 前，需要掌握幾個重點 :</p><ol><li><p><code>unittest</code> 是 python 原生套件，不需要額外安裝</p></li><li><p><code>unittest</code> 可以透過 Context Switch <code>mock.patch()</code> 來建立 Mock 物件，語法如下 :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>from</span> unittest <span style=color:#ff79c6>import</span> mock
</span></span><span style=display:flex><span><span style=color:#ff79c6>with</span> mock<span style=color:#ff79c6>.</span>patch(<span style=color:#ff79c6>&lt;</span>被替換的物件<span style=color:#ff79c6>&gt;</span>) <span style=color:#ff79c6>as</span> <span style=color:#ff79c6>&lt;</span>別名<span style=color:#ff79c6>&gt;</span> :
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 在 Context Switcher 範圍內只要出現 &lt;被替換的物件&gt;，就會被替換成 Mock 物件</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>...</span>
</span></span></code></pre></div></li></ol><p>讓我們試著實作剛剛的範例 :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>from</span> unittest <span style=color:#ff79c6>import</span> mock <span style=color:#6272a4># unittest 為 python 原生套件</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_check_response_greater_than_0_5</span>():
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 將 src.check_response 中的 call_external_api 替換成 mock_api_1 物件</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>with</span> mock<span style=color:#ff79c6>.</span>patch(<span style=color:#f1fa8c>&#34;src.check_response.call_external_api&#34;</span>) <span style=color:#ff79c6>as</span> mock_api_1:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># 指定 mock_api_1 物件的回傳值</span>
</span></span><span style=display:flex><span>        mock_api_1<span style=color:#ff79c6>.</span>return_value <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;response_value&#34;</span>: <span style=color:#bd93f9>0.95</span>} 
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#6272a4># 因為在 mock 的 context switcher 中，所以該 Function 執行過程中 \</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># 會把 call_external_api() 替換為 mock_api_1</span>
</span></span><span style=display:flex><span>        check_response_greater_than_0_5()
</span></span></code></pre></div><h2 id=pytest-mock>pytest-mock</h2><p>而 <code>pytest-mock</code> 則是另一個我喜歡使用的工具，好處是寫法簡潔！</p><p>然而，對於初接觸 Mock 的使用者來說，可能會覺得概念有點跳躍。</p><p>但在理解 <code>unittest</code> 的寫法後，你可以將 <code>pytest-mock</code> 視為 <code>unittest</code> 的簡潔版！</p><p>使用 <code>pytest-mock</code> 前需要先安裝套件 :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install pytest-mock
</span></span></code></pre></div><p>在使用 <code>pytest-mock</code> 時需要掌握 1 個重點 :</p><blockquote><p><strong>使用前須先將 <code>mocker</code> Fixture 加入 Test Case 中</strong></p></blockquote><p>你可以將 <code>pytest-mock</code> 想像成是幫你寫好一個名叫 <code>mocker</code> 的 Fixture，當你在 Test Case 中加入 <code>mocker</code> Fixture 後，就可以直接呼叫 <code>mocker.patch()</code> 來進行替換，相較於 <code>unittest</code> 框架的 Context Switcher 來說，使用上會更簡潔。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>from</span> pytest_mock <span style=color:#ff79c6>import</span> MockFixture
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> src.check_response <span style=color:#ff79c6>import</span> check_response_greater_than_0_5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_check_response_greater_than_0_5</span>(mocker: MockFixture):
</span></span><span style=display:flex><span>    mock_api_2 <span style=color:#ff79c6>=</span> mocker<span style=color:#ff79c6>.</span>patch(<span style=color:#f1fa8c>&#34;src.check_response.call_external_api&#34;</span>, return_value<span style=color:#ff79c6>=</span>{<span style=color:#f1fa8c>&#34;response_value&#34;</span>: <span style=color:#bd93f9>0.25</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result <span style=color:#ff79c6>=</span> check_response_greater_than_0_5()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>assert</span> result <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>False</span>
</span></span></code></pre></div><hr><h1 id=總結>總結</h1><p>讓我們來做個總結，在原先的架構中 :</p><p><img src=https://minglunwu.com/images/20230813/image.png alt=基本架構圖></p><p>由於我們無法確定 <code>call_external_api()</code> 的 Response 為何，當 Response 無法確定時，當然無法驗證後續的條件是否正確。</p><p>因此，我們透過 Mock 來替換 <code>call_external_api()</code>，使得在測試過程中，<code>call_external_api()</code> 可以輸出「特定」的 Response。</p><p>有了固定的前提，我們才可以驗證後續 Function 的行為是否正確 :</p><p><img src=https://minglunwu.com/images/20230813/image-3.png alt="Test Case 示意圖"></p><p>最終的測試案例如下 :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>from</span> src.check_response <span style=color:#ff79c6>import</span> check_response_greater_than_0_5
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> pytest_mock <span style=color:#ff79c6>import</span> MockFixture
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> unittest <span style=color:#ff79c6>import</span> mock
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> pytest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 使用 unittest 寫法</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_check_response_greater_than_0_5_true</span>():
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>with</span> mock<span style=color:#ff79c6>.</span>patch(<span style=color:#f1fa8c>&#34;src.check_response.call_external_api&#34;</span>) <span style=color:#ff79c6>as</span> mock_api_1:
</span></span><span style=display:flex><span>        mock_api_1<span style=color:#ff79c6>.</span>return_value <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;response_value&#34;</span>: <span style=color:#bd93f9>0.95</span>}
</span></span><span style=display:flex><span>        result <span style=color:#ff79c6>=</span> check_response_greater_than_0_5()
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>assert</span> result <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 使用 pytest-mock 寫法</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_check_response_greater_than_0_5_false</span>(mocker: MockFixture):
</span></span><span style=display:flex><span>    return_value <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;response_value&#34;</span>: <span style=color:#bd93f9>0.25</span>}
</span></span><span style=display:flex><span>    mock_api_2 <span style=color:#ff79c6>=</span> mocker<span style=color:#ff79c6>.</span>patch(<span style=color:#f1fa8c>&#34;src.check_response.call_external_api&#34;</span>, return_value<span style=color:#ff79c6>=</span>return_value)
</span></span><span style=display:flex><span>    result <span style=color:#ff79c6>=</span> check_response_greater_than_0_5()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>assert</span> result <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 使用 pytest-mock 寫法</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>test_check_response_greater_than_0_5_error</span>(mocker: MockFixture):
</span></span><span style=display:flex><span>    return_value <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>    mock_api_3 <span style=color:#ff79c6>=</span> mocker<span style=color:#ff79c6>.</span>patch(<span style=color:#f1fa8c>&#34;src.check_response.call_external_api&#34;</span>, return_value<span style=color:#ff79c6>=</span>return_value)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>with</span> pytest<span style=color:#ff79c6>.</span>raises(KeyError):
</span></span><span style=display:flex><span>        check_response_greater_than_0_5() <span style=color:#6272a4># 預期要拋出 KeyError</span>
</span></span></code></pre></div><p>在今天的筆記中，我們用圖解的方式說明 Mock 在測試中扮演的角色，並且整理了 Python 開發者常會使用到的 Mock 語法。</p><p>希望以上內容能幫助你更了解 Mock 是什麼，並且讓你可以實際在測試中使用 Mock!</p><p>有問題歡迎在下方留言！我們下次見！</p><hr><ul class=pager><li class=previous><a href=/notes/2023/vscode_python_extension.html/ data-toggle=tooltip data-placement=top title="如何透過 VSCode 的 Python Extension 進行 Debug ?">&larr;
Previous Post</a></li></ul><hr><div><h2>See Also</h2><div class=card><div class=card-content style=padding:2px><a class="title is-5" href=https://minglunwu.com/notes/2023/pytest_101_2.html/>Pytest 101 - 給 Python 開發者的測試入門 (2) - Mock 基礎介紹</a>
<span class=heading><time>(March 12, 2023)</time></span></div></div><div class=card><div class=card-content style=padding:2px><a class="title is-5" href=https://minglunwu.com/notes/2022/pytest_101.html/>Pytest 101 - 給 Python 開發者的測試入門</a>
<span class=heading><time>(March 4, 2022)</time></span></div></div><div class=card><div class=card-content style=padding:2px><a class="title is-5" href=https://minglunwu.com/notes/2023/vscode_python_extension.html/>如何透過 VSCode 的 Python Extension 進行 Debug ?</a>
<span class=heading><time>(July 29, 2023)</time></span></div></div></div><hr><script src=https://utteranc.es/client.js repo=MingLunWu/MingLunWu.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/ansible title=ansible>ansible</a>
<a href=/tags/fast-api title=fast-api>fast-api</a>
<a href=/tags/fast-api-tutorial title=fast-api-tutorial>fast-api-tutorial</a>
<a href=/tags/pytest-101 title=pytest-101>pytest-101</a>
<a href=/tags/python title=python>python</a>
<a href=/tags/test title=test>test</a>
<a href=/tags/tool title=tool>tool</a>
<a href=/tags/wsgi title=wsgi>wsgi</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:alen6997535@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/minglunwu><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.linkedin.com/in/ming-lun-wu-637020142/><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://medium.com/@minglun-wu><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-medium fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; MingLun Blog 2023<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>