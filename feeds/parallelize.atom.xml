<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>MingLun's Blog - Parallelize</title><link href="/" rel="alternate"></link><link href="/feeds/parallelize.atom.xml" rel="self"></link><id>/</id><updated>2020-05-20T18:30:00+08:00</updated><entry><title>Python 平行化運算 - Multi-Processing</title><link href="/notes/2020/20200520.html" rel="alternate"></link><published>2020-05-20T18:30:00+08:00</published><updated>2020-05-20T18:30:00+08:00</updated><author><name>MingLun Allen Wu</name></author><id>tag:None,2020-05-20:/notes/2020/20200520.html</id><summary type="html">&lt;p&gt;透過 Python 的 Multi-Processing Pool來進行平行處理，對於資料前處理的效率有很大的提升。&lt;/p&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href="#abstract"&gt;Abstract&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#presquile"&gt;Presquile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#concept"&gt;Concept&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusion"&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p id="abstract"&gt;&lt;/p&gt;

&lt;h1&gt;Abstract&lt;/h1&gt;
&lt;p&gt;使用Python 進行資料前處理時，大量的資料常會造成處理時間過長，這時候總希望能透過平行化處理來解決。 提到平行化處理又總會陷入疑惑: 「該使用Multi-Thread 還是 Multi-Process」?&lt;/p&gt;
&lt;p&gt;以我的經驗，&lt;strong&gt;在進行「資料前處理」時&lt;/strong&gt;，其實是需要CPU持續計算的，所以並不適合使用「Multi-thread」。今天這則筆記是嘗試以「Multi-Process」的方式來對前處理階段進行加速。&lt;/p&gt;
&lt;p&gt;近期需要使用 &lt;code&gt;transformers&lt;/code&gt;套件來將長篇幅的文字轉換成 index，並且裁切成長度512的 array。 &lt;code&gt;transformers&lt;/code&gt;執行的速度並不慢，但是當處理的資料達到七～八萬篇時，整個過程也需要耗費將近三個小時。 但是在計算的過程中，打開 &lt;code&gt;htop&lt;/code&gt;會發現只使用一顆CPU在計算，這時總會希望能夠用全部的CPU資源來進行加速:&lt;/p&gt;
&lt;p&gt;&lt;img style="display:block; margin-left:auto; margin-right:auto; width:50%;" src="https://minglunwu.github.io/images/20200520/single_process.png"&gt;&lt;/p&gt;
&lt;p&gt;我希望能夠透過平行化處理達到下面這個狀態：&lt;/p&gt;
&lt;p&gt;&lt;img style="display:block; margin-left:auto; margin-right:auto; width:50%;" src="https://minglunwu.github.io/images/20200520/multi_process.png"&gt;&lt;/p&gt;
&lt;p&gt;最後成功地將處理時間從 2.5小時 縮短到 20 分鐘！&lt;/p&gt;
&lt;hr&gt;
&lt;p id="presquile"&gt;&lt;/p&gt;

&lt;h1&gt;Presquile&lt;/h1&gt;
&lt;p&gt;使用 Multi-Processing 進行平行運算前，需要確認:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於不同的&lt;strong&gt;Process間無法共享資料&lt;/strong&gt;，所以如果平行運算的過程中需要互相取用資料，就不適合透過Multi-Process的方式執行。   舉例來說：我的碩士論文需要尋訪數萬個字的同義字來建立一個Graph，如果使用Multi-Process是沒有辦法操作一個共同的Graph的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p id="concept"&gt;&lt;/p&gt;

&lt;h1&gt;Concept&lt;/h1&gt;
&lt;p&gt;這次透過 python 內建的 &lt;code&gt;multiprocessing&lt;/code&gt;來實作，我們將實作的重要觀念分成四個部分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Function: &lt;/p&gt;
&lt;p&gt;把要透過平行化進行加速的任務封裝在 Function中。&lt;/p&gt;
&lt;p&gt;舉例來說如果想要計算當前資料集每一個商品id的"price"欄位總和: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;agg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;price&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tasks:&lt;/p&gt;
&lt;p&gt;Tasks是一個 List，因為我們要同時使用多個Process進行計算，所以要在此對參數進行分割。 假設共有 500 篇文章，我們可以將資料分割為:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tasks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pool:&lt;/p&gt;
&lt;p&gt;透過 &lt;code&gt;multiprocessing.pool&lt;/code&gt;可以自動建立分工機制，我們不需要做額外的處理與設定:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multiprocessing&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;processes&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map: &lt;/p&gt;
&lt;p&gt;在設定好 Function, Tasks 及 Pool後，我們就能透過 &lt;code&gt;pool&lt;/code&gt;的 &lt;code&gt;map&lt;/code&gt;進行平行處理:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# 第一個放Function, 第二個放分割後的參數&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum_function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;執行上述程式碼時， &lt;code&gt;pool&lt;/code&gt;會自動將 tasks 中的參數依序丟到 N個 Process中執行 sum_function，並且在執行結束後，將結果回傳到result。 &lt;/p&gt;
&lt;p&gt;因為 tasks 中共有5個 Element，所以最後Result也會有5個處理完畢的Element. 這時候可以再根據需要將其 Aggregate成最後的結果。&lt;/p&gt;
&lt;p&gt;再來一個較為複雜的範例：&lt;/p&gt;
&lt;p&gt;我們要將一個Dataframe先移除 Stop word (&lt;code&gt;remove_stopwrods()&lt;/code&gt;)，再將其裁切為長度512的段落(&lt;code&gt;truncate_text()&lt;/code&gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;mp&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove_stopwords&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c1"&gt;# 移除 Stop word&lt;/span&gt;
        &lt;span class="c1"&gt;# Do something.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;cleaned_text&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;truncate_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  &lt;span class="c1"&gt;# 裁切文字，將長篇幅文字裁切成 512個字的list.&lt;/span&gt;
        &lt;span class="c1"&gt;# Do something.&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="n"&gt;word_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="n"&gt;word_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="n"&gt;word_list&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataframe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 儲存每一個Process執行的成果。&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;dataframe&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterrows&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;cleaned_text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;remove_stopwords&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;text&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c1"&gt;# Remove stopwords&lt;/span&gt;
        &lt;span class="n"&gt;truncated_res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;truncate_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cleaned_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# Truncate long words to list.&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用到的Function有三項，不需要了解Function的功能是做什麼，只需要知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;remove_stopwords()&lt;/code&gt;以及 &lt;code&gt;truncate_text()&lt;/code&gt;是做資料前處理的兩個function。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process()&lt;/code&gt;則是接受分割後的「dataframe」，使用 &lt;code&gt;remove_stopwords()&lt;/code&gt;及 &lt;code&gt;truncate_text()&lt;/code&gt;對dataframe中的每一筆資料進行處理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我們可以在平行化的過程中使用多個Function，但是在使用 &lt;code&gt;multiprocessing.pool&lt;/code&gt;進行平行化處理時，只能接受一個Function，所以需要把所有流程中使用到的Function都打包在一起。 (就如同上例將 &lt;code&gt;remove_stopwords()&lt;/code&gt;及 &lt;code&gt;truncate_text()&lt;/code&gt;都打包在 &lt;code&gt;process()&lt;/code&gt;中。)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;df&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;tasks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
    &lt;span class="n"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;processes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 平行處理，全部處理完後會將結果存回 result.&lt;/span&gt;

    &lt;span class="n"&gt;final_result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;some_aggregation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#最後可能需要再對資料進行整合。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p id="conclusion"&gt;&lt;/p&gt;

&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;透過Multi-Process的方式能夠大幅度的提升資料前處理的效率，在沒有集群的情況下，利用多顆CPU來增加速度。 &lt;/p&gt;
&lt;p&gt;最近也嘗試在研究 &lt;a href="https://dask.org"&gt;&lt;strong&gt;Dask&lt;/strong&gt;&lt;/a&gt;這個套件，能夠輕易地切換不同模式： "Multi-thread"、"Multi-process"以及多台機器組成的集群，對於 &lt;code&gt;Numpy&lt;/code&gt;及 &lt;code&gt;Sklearn&lt;/code&gt;等機器學習套件也有很好的支援，很適合用來進行Python的平行化處理。&lt;/p&gt;
&lt;p&gt;希望本篇筆記對點閱的你有幫助！ 有任何問題歡迎隨時跟我交流！&lt;/p&gt;</content><category term="Parallelize"></category><category term="Python"></category><category term="Parallelize"></category></entry></feed>